<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
	</head>
	<body>
		<script>
			/*
//一:生成实例对象的原始模式(代码重复)
			var cat = {name:'',color:''};
			var cat1 = {};
			cat1.name= '大猫';
			cat1.color = '黄色';
			var cat2 = {};
			cat2.name = '二毛';
			cat2.color = '白色';
			console.log(cat);
			console.log(cat1);
			console.log(cat2);
			*/
			
			/*
//二:原始模式的改进(封装对象)
			function cat(name,color){
				return {name:name,color:color}
			}
			var cat1 = cat('大猫','黄色');
			var cat2 = cat('二毛','白色');
			console.log(cat);
			console.log(cat1);
			console.log(cat2);
			*/
			
			/*
//三:构造函数（Constructor）模式。
//所谓"构造函数"，其实就是一个普通函数，但是内部使用了this关键字。
//任何函数调用时前面加new都可以创建成一个自定义对象，为了避免混淆该函数与普通函数，默认规则该函数首字母大写，称为构造函数。
//对构造函数使用new关键字，就能生成实例，并且this变量会绑定在实例对象上。
			function Cat(name,color){
				this.name=name;
				this.color=color;
			}
			var cat1 =new Cat('大猫','黄色');
			var cat2 =new Cat('二毛','白色');
//这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。
			console.log(Cat);
			console.log(cat1);
			console.log(cat2);
//			alert(cat1.name);
//			alert(cat1.color);
			alert(cat1.constructor==cat);
			alert(cat2.constructor==cat);
//Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。
			alert(cat1 instanceof Cat);
			alert(cat2 instanceof Cat);
			*/
			
			/*
//四:函数构造模式的问题(浪费内存)
			function Cat(name,color){
				this.name=name;
				this.color=color;
				this.type='猫科动物';
				this.eat=function(){alert('吃老鼠');}
			}
			var cat1 = new Cat('大猫','黄色');
			var cat2 =new Cat('二毛','白色');
			console.log(Cat);
			console.log(cat1);
			console.log(cat2);
//			alert(cat1.type);
//			cat1.eat();
			alert(cat1.type==cat2.type);
			alert(cat1.eat==cat2.eat);
			*/
			
//五:Prototype模式
//Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。
//这个对象的所有属性和方法，都会被构造函数的实例继承。
			function Cat(name,color){
				this.name=name;
				this.color=color;
			}
			Cat.prototype.type='猫科动物';
			Cat.prototype.eat=function(){alert('吃老鼠')};
			var cat1 = new Cat('大猫','黄色'); 
			var cat2 = new Cat('二毛','白色'); 
			console.log(Cat);
			console.log(cat1);
			console.log(cat2);
//			alert(cat1.type);
//			cat1.eat();
			alert(Cat.prototype.isPrototypeOf(cat1));
			alert(Cat.prototype.isPrototypeOf(cat2));
			alert(cat1.type==cat2.type);
			alert(cat1.eat==cat2.eat);
			
//六:Prototype模式的验证方法
/*
 	6.1：isPrototypeOf()方法  用来判断某个prototype对象和某个实例之间的关系。
 			alert(Cat.prototype.isPrototypeOf(cat1));//true
 			alert(Cat.prototype.isPrototypeOf(cat2));//true
 	6.2：hasOwnPrototype()方法  用来判断某个属性到底是本地属性还是继承自prototype对象的属性。
 			alert(cat1.hasOwnPrototype("name"));//true
 			alert(cat1.hasOwnPrototype("type"));//false
 	6.3：in运算符  可以用来判断某个实例是否含有某个属性，不管是不是本地属性。
 			alert('name' in cat1);//true
 			alert('type' in cat1);//true
 		in运算符  可以用来遍历某个对象的所有属性，不管是本地属性还是继承属性。
 		 */
 			for(var prop in cat1){
 				alert("cat1["+prop+"]="+cat1[prop]);
 			}

		</script> 
	</body>
</html>
