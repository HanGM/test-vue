<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>作用域、变量提升</title>
	</head>
	<body>
	<script type="text/javascript">

//第1题
 console.log(a); 
 
 var a=12; 
 
function fn(){
		console.log(a);
        var a=13;	
	}  
 
fn();   
 
console.log(a);  
/*
解答：
1.在代码执行前，会进行变量提升（带var 和 函数）
2.代码从上向下执行时，会跳过fn函数的声明，因为变量提升时已进行定义和声明
3.fn() 开始执行，会走函数的执行过程：
   1）形成私有作用域
   2) 形参赋值
   3) 变量提升
   4）代码从上到下执行
   5）作用域是否销毁
结果：
//undefined undefined 12
*/
 
 
//第2题
console.log(a);  
 
var a=12;
function fn(){
		console.log(a);
        a=13;
	}	
	
fn();
console.log(a); 
/*
解答：
1.变量提升 a（只声明）  fn(声明+定义)
2.代码从上到下执行 跳过fn的定义代码段，因为变量提升时已经执行过
3.fn()  执行函数的执行过程;没有私有变量那么a 会沿着作用域链查找变量
结果：
//undefined 12 13
*/
 
 
//第3题
console.log(a); 
    a=12;
function fn(){
		console.log(a);
		a=13;	
	}	
	
fn();
console.log(a);  
 
/*
解答：
1.变量提升阶段 a 不会提升，所以在之前调用会报错 只有进行var 修饰符 声明的变量才会变量提升
结果： 
//程序报错 Uncaught ReferenceError: a is not defined
*/
 
//第4题
var foo=1;  
 
function bar(){
       if(!foo){
           var foo=10; 
       }
       console.log(foo); 
   }
   
bar();
/* 
解答：
1.变量提升 foo (只声明) bar（声明+定义）
2.function bar 代码段会跳过 
3.bar() 执行函数的执行过程
    函数的私有作用域：
    1.无论条件是否成立都会进行变量提升
    2.undefined 转 boolean 是 false (数据类型转boolean的false几种类型) 
    3.false 取反 true 所以代码从上到下执行 会执行 var foo = 10 
结果：
//10 
*/
 
 
//第5题
var n=0;  
  
 function a(){
	  var n=10; //11 12
	  function b(){
		  n++; 
          alert(n);       
      }
	  b();
      return b; 
 }
 
var c=a(); //11
c(); //12
alert(n);  //0
/*
解答：
1.变量提升 n (只声明) a(声明+定义) c(只声明)
2.代码执行 先跳过 function a(){}
3. c 等于 a() 的执行结果
    1).函数的执行过程
    2).函数作用域不销毁的条件
        1.函数的返回值为引用类型
        2.返回值被其他变量使用
结果：
var c=a(); //11
c();       //12
alert(n);  //0
*/
 
 
 
//第6题
var a=10,b=11,c=12;
   
function test(a){
        a=1;var b=2;c=3;
   }  
 
test(10);
alert(a);  alert(b);   alert(c); 
/*
解答：
1.变量提升 a b c （只声明） test(声明+定义)
2.代码从上到下执行 跳过 function test(a) {}
3.test(10) 函数执行过程：
    1.形成私有作用域
    2.形参赋值（也是私有变量）
    3.变量提升
    4.代码从上到下执行
    5.作用域是否销毁
4.作用域链查找非私有变量
结果：
//10 11 3 
*/
 
 
//第7题
if(!("a" in window)){   
      var a=1;
   }
 
alert(a);  
/*
解答：
1.变量提升;
   1.无论条件是否成立都会进行变量提升
2. a为undefined  "a" in window 返回 true 
3.所以不会执行 var a = 1;这段代码
结果：
//undefined
*/
 
//第8题
var a=4;  
 
   function b(x,y,a) {	   
        alert(a); 
        arguments[2]=10;        
        alert(a); 
   }
 
a=b(1,2,3);   //3 10 
alert(a);  //undefined
/*
解答：
1.变量提升 a（只声明） b（声明+定义）
2.function b（）{}跳过
3.函数的执行过程
4.把 b(1,2,3) 的执行结果赋值给 a
结果：
*/
 
 
//第9题
var foo='hello';  
 
   (function(foo){
      console.log(foo);
      var foo = foo ||'world';
      console.log(foo);
   })(foo);
 
console.log(foo); 
/*
解答：
1.变量提升 foo 
    1.自执行函数不进行变量提升
2.自执行函数执行 函数执行过程
    1.形成私有作用域
    2.形参赋值 
    3.变量提升
      1.如果变量名重复，不再进行重复声明，但要重新定义；
结果：
//hello hello hello
*/
 
 
//第10题
var a=9;  
 
function fn(){ 
	   a=0; //全局变量 0 1	0   1 2
       return function(b){ return b+a++; }    
    }
 
var f=fn() 
var m=f(5); 
alert(m);         //5
var n=fn()(5);
alert(n);         //5
var x=f(5);       //6
alert(x);         //2
/*
解答：
1.变量提升 a(定义) fn(声明+定义) f m n  x （定义）
2.function fn（） {} 跳过
3. 执行 var f = fn() 返回fn()的返回值 
    1.函数的执行过程
    2.函数作用域不销毁
    3.作用域链
结果：
// 5 5 6 2
*/
	</script>
	</body>
</html>
